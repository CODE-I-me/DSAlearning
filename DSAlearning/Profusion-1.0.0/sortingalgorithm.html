<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithms in DSA</title>
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            line-height: 1.7;
            padding: 40px 15px;
            background-color: #f9f9f9;
        }
        h1, h2, h3 {
            color: #343a40;
            margin-top: 30px;
        }
        ul, ol {
            margin-left: 20px;
        }
        pre {
            background: #f4f4f4;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
        }
        .container {
            max-width: 960px;
            margin: auto;
            background: #fff;
            padding: 40px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        .assignment {
            background: #e9f7ef;
            padding: 20px;
            border-left: 5px solid #2ecc71;
            margin-top: 30px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Sorting Algorithms in Data Structures</h1>

        <p><strong>Sorting</strong> is the process of arranging data in a specific order â€” typically in ascending or descending order. Efficient sorting is crucial in optimizing search and data processing operations.</p>

        <h2>Types of Sorting Algorithms</h2>
        <ul>
            <li><strong>Bubble Sort</strong></li>
            <li><strong>Selection Sort</strong></li>
            <li><strong>Insertion Sort</strong></li>
            <li><strong>Merge Sort</strong></li>
            <li><strong>Quick Sort</strong></li>
            <li><strong>Heap Sort</strong></li>
            <li><strong>Radix Sort</strong></li>
        </ul>

        <h2>Bubble Sort (Simple but Inefficient)</h2>
        <p>Compares adjacent elements and swaps them if they are in the wrong order.</p>
        <pre><code>void bubbleSort(int arr[], int n) {
    for(int i = 0; i < n-1; i++) {
        for(int j = 0; j < n-i-1; j++) {
            if(arr[j] > arr[j+1]) {
                // Swap
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}
        </code></pre>

        <h2>Insertion Sort</h2>
        <p>Builds the final sorted array one element at a time.</p>
        <pre><code>void insertionSort(int arr[], int n) {
    for(int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        while(j >= 0 && arr[j] > key) {
            arr[j+1] = arr[j];
            j--;
        }
        arr[j+1] = key;
    }
}
        </code></pre>

        <h2>Merge Sort (Divide and Conquer)</h2>
        <p>Divides the array into halves, sorts them recursively, and merges the results.</p>
        <pre><code>void merge(int arr[], int l, int m, int r) {
    int n1 = m - l + 1;
    int n2 = r - m;
    int L[n1], R[n2];

    for(int i = 0; i < n1; i++)
        L[i] = arr[l+i];
    for(int j = 0; j < n2; j++)
        R[j] = arr[m+1+j];

    int i = 0, j = 0, k = l;
    while(i < n1 && j < n2) {
        if(L[i] <= R[j])
            arr[k++] = L[i++];
        else
            arr[k++] = R[j++];
    }

    while(i < n1) arr[k++] = L[i++];
    while(j < n2) arr[k++] = R[j++];
}
        </code></pre>

        <h2>Quick Sort (Efficient and Fast)</h2>
        <p>Picks a pivot, partitions the array, and sorts each part recursively.</p>
        <pre><code>int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    for(int j = low; j < high; j++) {
        if(arr[j] < pivot) {
            i++;
            int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;
        }
    }
    int temp = arr[i+1]; arr[i+1] = arr[high]; arr[high] = temp;
    return i + 1;
}

void quickSort(int arr[], int low, int high) {
    if(low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
        </code></pre>

        <h2>Time Complexity Comparison</h2>
        <table class="table table-bordered table-striped">
            <thead>
                <tr>
                    <th>Algorithm</th>
                    <th>Best</th>
                    <th>Average</th>
                    <th>Worst</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>Bubble Sort</td><td>O(n)</td><td>O(nÂ²)</td><td>O(nÂ²)</td></tr>
                <tr><td>Selection Sort</td><td>O(nÂ²)</td><td>O(nÂ²)</td><td>O(nÂ²)</td></tr>
                <tr><td>Insertion Sort</td><td>O(n)</td><td>O(nÂ²)</td><td>O(nÂ²)</td></tr>
                <tr><td>Merge Sort</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td></tr>
                <tr><td>Quick Sort</td><td>O(n log n)</td><td>O(n log n)</td><td>O(nÂ²)</td></tr>
                <tr><td>Heap Sort</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td></tr>
            </tbody>
        </table>

        <div class="assignment">
            <h2>ðŸ“˜ Assignments</h2>
            <ol>
                <li>Implement bubble sort and test it on user-input array.</li>
                <li>Write code for insertion sort and compare it with selection sort.</li>
                <li>Implement merge sort and count the number of merge steps.</li>
                <li>Write quick sort and trace the pivot at each step.</li>
                <li>Compare sorting algorithms with random vs sorted input.</li>
            </ol>
        </div>

        <div style="margin-top: 30px;">
            <a href="services.html" class="btn btn-primary">&larr; Back to DSA Topics</a>
        </div>
    </div>
</body>
</html>
